# 消息分组与分类方案 - 风险点修复 v2（修正版）

> 基于专业点评修正的最终方案

## 🚨 高优先级问题修正

### 问题 1：构造函数签名不应修改

#### ❌ 错误方案（会破坏现有调用）
```javascript
// 错误：重新生成 requestId，丢失现有参数
constructor({ apiKey, requestBody, headers, isStream }) {
  this.requestId = headers['x-request-id'] || uuidv4()  // ❌ 覆盖传入的
}
```

#### ✅ 正确方案（复用现有参数）

**保持现有签名不变，只新增 messageGroupId 字段**

```javascript
class HistoryRecorder {
  constructor({
    apiKey,
    requestBody,
    requestId,           // ✅ 保留现有参数
    headers,
    isStream,
    providedSessionId,   // ✅ 保留现有参数
    stickySessionId,     // ✅ 保留现有参数
    forceNewSession      // ✅ 保留现有参数
  }) {
    this.apiKey = apiKey
    this.requestBody = requestBody || {}
    this.requestId = requestId           // ✅ 使用传入的 requestId
    this.headers = headers
    this.isStream = isStream
    this.providedSessionId = providedSessionId
    this.stickySessionId = stickySessionId
    this.forceNewSession = forceNewSession

    // 🆕 新增：基于传入的 requestId 生成分组 ID
    this.messageGroupId = this.generateGroupId()

    this.assistantText = ''
    this.streamBlocks = new Map()
    this.sessionId = null
    this.sessionWasCreated = false
    this.isClosed = false
    this.skipRecording = false

    // 🆕 新增：流式事件状态管理
    this.currentBlockType = null       // 'thinking' | 'text' | 'tool_use'
    this.pendingBlocks = []            // 待写入的消息块
  }

  // 🆕 生成分组 ID
  generateGroupId() {
    // 使用传入的 requestId，而不是重新生成
    return `group_${this.apiKey.id}_${this.requestId}_${Date.now()}`
  }
}
```

**调用方无需修改**：
```javascript
// src/services/history/historyService.js:660
const recorder = new HistoryRecorder({
  apiKey,
  requestBody,
  requestId,              // ✅ 继续传入
  headers,
  isStream,
  providedSessionId,      // ✅ 继续传入
  stickySessionId,        // ✅ 继续传入
  forceNewSession         // ✅ 继续传入
})
```

---

### 问题 2：captureStreamChunk 不能直接 await

#### ❌ 错误方案（会阻塞流）
```javascript
async captureStreamChunk(chunk) {
  if (chunk.type === 'content_block_start') {
    // ❌ 直接 await 会阻塞流式响应
    await sessionStore.appendMessage({...})
  }
}
```

#### ✅ 正确方案（缓冲 + 异步队列）

**方案 A：缓冲到内存，在 finalizeStream 时批量写入（推荐）**

```javascript
class HistoryRecorder {
  constructor(...) {
    // ...
    this.pendingMessages = []  // 🆕 消息缓冲队列
    this.thinkingBuffer = ''   // 🆕 思考过程文本缓冲
  }

  captureStreamChunk(chunk) {
    // 1. content_block_start：记录块类型
    if (chunk.type === 'content_block_start') {
      const blockType = chunk.content_block?.type

      if (blockType === 'tool_use') {
        // 工具调用：缓冲到队列
        this.pendingMessages.push({
          role: 'assistant',
          subtype: 'tool_use',
          messageGroupId: this.messageGroupId,
          content: JSON.stringify(chunk.content_block),
          isVisible: false,
          createdAt: new Date().toISOString(),
          metadata: { blockType: 'tool_use' }
        })
      } else if (blockType === 'thinking') {
        this.currentBlockType = 'thinking'
        this.thinkingBuffer = ''
      } else if (blockType === 'text') {
        this.currentBlockType = 'text'
      }
    }

    // 2. content_block_delta：累积文本
    if (chunk.type === 'content_block_delta') {
      if (this.currentBlockType === 'thinking') {
        this.thinkingBuffer += chunk.delta?.text || ''
      } else if (this.currentBlockType === 'text') {
        this.assistantText += chunk.delta?.text || ''
      }
    }

    // 3. content_block_stop：块结束，缓冲消息
    if (chunk.type === 'content_block_stop') {
      if (this.currentBlockType === 'thinking' && this.thinkingBuffer) {
        // 缓冲思考过程（不立即写入）
        this.pendingMessages.push({
          role: 'assistant',
          subtype: 'thinking',
          messageGroupId: this.messageGroupId,
          content: this.thinkingBuffer,
          isVisible: false,
          createdAt: new Date().toISOString(),
          metadata: { blockType: 'thinking' }
        })
        this.thinkingBuffer = ''
      }
      this.currentBlockType = null
    }

    // ✅ 不做任何 await，保持同步
  }

  async finalizeStream(error) {
    if (this.isClosed || !config.enabled || !this.sessionId || this.skipRecording) {
      return
    }

    try {
      // 1. 批量写入缓冲的消息（思考过程、工具调用）
      for (const msg of this.pendingMessages) {
        await sessionStore.appendMessage({
          apiKeyId: this.apiKey.id,
          sessionId: this.sessionId,
          message: msg
        })
      }

      // 2. 写入最终回复
      if (this.assistantText) {
        await sessionStore.appendMessage({
          apiKeyId: this.apiKey.id,
          sessionId: this.sessionId,
          message: {
            role: 'assistant',
            subtype: 'message',
            messageGroupId: this.messageGroupId,
            content: this.assistantText,
            isVisible: true,
            createdAt: new Date().toISOString(),
            metadata: {
              finishReason: this.streamStopReason || 'end_turn',
              error: error ? error.message : undefined
            }
          }
        })
      }

      // 3. 清空缓冲
      this.pendingMessages = []
    } catch (err) {
      logger.error('Failed to finalize stream messages:', err)
    }

    this.isClosed = true
  }
}
```

**方案 B：后台异步队列（复杂场景）**

```javascript
class MessageQueue {
  constructor() {
    this.queue = []
    this.processing = false
  }

  enqueue(task) {
    this.queue.push(task)
    if (!this.processing) {
      this.processQueue()
    }
  }

  async processQueue() {
    this.processing = true
    while (this.queue.length > 0) {
      const task = this.queue.shift()
      try {
        await task()
      } catch (err) {
        logger.error('Message queue task failed:', err)
      }
    }
    this.processing = false
  }
}

// 使用全局队列
const messageQueue = new MessageQueue()

class HistoryRecorder {
  captureStreamChunk(chunk) {
    // 不阻塞流，将任务入队
    if (chunk.type === 'content_block_stop' && this.thinkingBuffer) {
      messageQueue.enqueue(async () => {
        await sessionStore.appendMessage({
          sessionId: this.sessionId,
          message: {
            subtype: 'thinking',
            content: this.thinkingBuffer,
            // ...
          }
        })
      })
    }
  }
}
```

**推荐使用方案 A**：缓冲到内存，在 `finalizeStream` 时批量写入，简单可靠。

---

## 🟡 中等优先级问题修正

### 问题 3：思考块重复写入矛盾

#### ❌ 错误方案（前后矛盾）

**错误点 1**：在 `content_block_start` 就写入
```javascript
if (chunk.type === 'content_block_start' && blockType === 'thinking') {
  await sessionStore.appendMessage({...})  // ❌ 立即写入
}
```

**错误点 2**：在 `content_block_stop` 又写入
```javascript
if (chunk.type === 'content_block_stop' && this.currentBlockType === 'thinking') {
  await sessionStore.appendMessage({...})  // ❌ 再次写入
}
```

**结果**：同一思考块被写入两次！

---

#### ✅ 正确方案（统一逻辑）

**策略：start 时标记状态，delta 时累积内容，stop 时缓冲消息**

```javascript
captureStreamChunk(chunk) {
  // 1. content_block_start：仅标记类型，不写入
  if (chunk.type === 'content_block_start') {
    const blockType = chunk.content_block?.type

    if (blockType === 'tool_use') {
      // 工具调用：立即缓冲（因为已经是完整数据）
      this.pendingMessages.push({
        role: 'assistant',
        subtype: 'tool_use',
        messageGroupId: this.messageGroupId,
        content: JSON.stringify(chunk.content_block),
        isVisible: false,
        createdAt: new Date().toISOString()
      })
    } else if (blockType === 'thinking') {
      // ✅ 仅标记，不写入
      this.currentBlockType = 'thinking'
      this.thinkingBuffer = ''
    } else if (blockType === 'text') {
      // ✅ 仅标记，不写入
      this.currentBlockType = 'text'
    }
  }

  // 2. content_block_delta：累积文本
  if (chunk.type === 'content_block_delta') {
    if (this.currentBlockType === 'thinking') {
      this.thinkingBuffer += chunk.delta?.text || ''
    } else if (this.currentBlockType === 'text') {
      this.assistantText += chunk.delta?.text || ''
    }
  }

  // 3. content_block_stop：缓冲完整消息
  if (chunk.type === 'content_block_stop') {
    if (this.currentBlockType === 'thinking' && this.thinkingBuffer) {
      // ✅ 在 stop 时缓冲（只写一次）
      this.pendingMessages.push({
        role: 'assistant',
        subtype: 'thinking',
        messageGroupId: this.messageGroupId,
        content: this.thinkingBuffer,
        isVisible: false,
        createdAt: new Date().toISOString(),
        metadata: { blockType: 'thinking' }
      })
      this.thinkingBuffer = ''
    }
    this.currentBlockType = null
  }
}
```

**流程图**：
```
content_block_start (type: thinking)
  ↓
  标记: this.currentBlockType = 'thinking'
  初始化: this.thinkingBuffer = ''
  ↓
content_block_delta (多次)
  ↓
  累积: this.thinkingBuffer += text
  ↓
content_block_stop
  ↓
  缓冲消息: this.pendingMessages.push({...})
  清空: this.thinkingBuffer = ''
  ↓
finalizeStream
  ↓
  批量写入: for (msg of pendingMessages) { await append(msg) }
```

---

## 📋 修正后的完整实现

### 1. HistoryRecorder 类完整代码

```javascript
class HistoryRecorder {
  constructor({
    apiKey,
    requestBody,
    requestId,           // ✅ 保留现有参数
    headers,
    isStream,
    providedSessionId,
    stickySessionId,
    forceNewSession
  }) {
    this.apiKey = apiKey
    this.requestBody = requestBody || {}
    this.requestId = requestId
    this.headers = headers
    this.isStream = isStream
    this.providedSessionId = providedSessionId
    this.stickySessionId = stickySessionId
    this.forceNewSession = forceNewSession

    // 🆕 生成分组 ID
    this.messageGroupId = `group_${apiKey.id}_${requestId}_${Date.now()}`

    // 现有字段
    this.assistantText = ''
    this.streamBlocks = new Map()
    this.sessionId = null
    this.sessionWasCreated = false
    this.isClosed = false
    this.skipRecording = false

    // 🆕 流式事件状态
    this.currentBlockType = null
    this.thinkingBuffer = ''
    this.pendingMessages = []  // 消息缓冲队列
  }

  async init() {
    // ... 现有逻辑保持不变
    const userMessage = HistoryRecorder.extractUserMessage(this.requestBody)

    // ⚠️ 保留现有的空消息保护
    if (!userMessage) {
      return this
    }

    // 🆕 检测系统消息
    const messageType = this.detectMessageType(userMessage.content)

    await sessionStore.appendMessage({
      apiKeyId: this.apiKey.id,
      sessionId: this.sessionId,
      message: {
        role: messageType.role,        // 'user' | 'system'
        subtype: messageType.subtype,  // 'message' | 'reminder'
        messageGroupId: this.messageGroupId,  // ✅ 使用分组 ID
        content: userMessage.content,
        isVisible: messageType.isVisible,
        createdAt: new Date().toISOString(),
        model: this.requestBody?.model,
        requestId: this.requestId
      }
    })
  }

  // 🆕 检测消息类型
  detectMessageType(content) {
    if (/<system-reminder>/i.test(content)) {
      return { role: 'system', subtype: 'reminder', isVisible: false }
    }
    if (/<important>/i.test(content)) {
      return { role: 'system', subtype: 'important', isVisible: false }
    }
    return { role: 'user', subtype: 'message', isVisible: true }
  }

  // ✅ 保持同步，不阻塞流
  captureStreamChunk(chunk) {
    if (chunk.type === 'content_block_start') {
      const blockType = chunk.content_block?.type

      if (blockType === 'tool_use') {
        this.pendingMessages.push({
          role: 'assistant',
          subtype: 'tool_use',
          messageGroupId: this.messageGroupId,
          content: JSON.stringify(chunk.content_block),
          isVisible: false,
          createdAt: new Date().toISOString()
        })
      } else if (blockType === 'thinking') {
        this.currentBlockType = 'thinking'
        this.thinkingBuffer = ''
      } else if (blockType === 'text') {
        this.currentBlockType = 'text'
      }
    }

    if (chunk.type === 'content_block_delta') {
      if (this.currentBlockType === 'thinking') {
        this.thinkingBuffer += chunk.delta?.text || ''
      } else if (this.currentBlockType === 'text') {
        this.assistantText += chunk.delta?.text || ''
      }
    }

    if (chunk.type === 'content_block_stop') {
      if (this.currentBlockType === 'thinking' && this.thinkingBuffer) {
        this.pendingMessages.push({
          role: 'assistant',
          subtype: 'thinking',
          messageGroupId: this.messageGroupId,
          content: this.thinkingBuffer,
          isVisible: false,
          createdAt: new Date().toISOString()
        })
        this.thinkingBuffer = ''
      }
      this.currentBlockType = null
    }

    // ✅ 同步返回，不阻塞流
  }

  async finalizeStream(error) {
    if (this.isClosed || !config.enabled || !this.sessionId || this.skipRecording) {
      return
    }

    try {
      // 批量写入缓冲消息
      for (const msg of this.pendingMessages) {
        await sessionStore.appendMessage({
          apiKeyId: this.apiKey.id,
          sessionId: this.sessionId,
          message: msg
        })
      }

      // 写入最终回复
      if (this.assistantText) {
        await sessionStore.appendMessage({
          apiKeyId: this.apiKey.id,
          sessionId: this.sessionId,
          message: {
            role: 'assistant',
            subtype: 'message',
            messageGroupId: this.messageGroupId,
            content: this.assistantText,
            isVisible: true,
            createdAt: new Date().toISOString(),
            metadata: {
              // ✅ 复用 this.streamStopReason（在 handleStreamEvent 中已赋值）
              finishReason: this.streamStopReason || 'end_turn',
              error: error ? error.message : undefined
            }
          }
        })
      }

      this.pendingMessages = []
    } catch (err) {
      logger.error('Failed to finalize stream:', err)
    }

    this.isClosed = true
  }

  // 🆕 非流式场景：精确检测
  async recordAssistantResponse({ text, raw, finishReason, model, error }) {
    if (!config.enabled || !this.sessionId || this.skipRecording) {
      return
    }

    // 检测是否为思考过程
    const isThinking = this.detectThinkingContent(text, raw, { finishReason })

    await sessionStore.appendMessage({
      apiKeyId: this.apiKey.id,
      sessionId: this.sessionId,
      message: {
        role: 'assistant',
        subtype: isThinking.subtype,
        messageGroupId: this.messageGroupId,  // ✅ 复用分组 ID
        content: text,
        isVisible: isThinking.isVisible,
        createdAt: new Date().toISOString(),
        model,
        metadata: { finishReason, error: error?.message }
      }
    })
  }

  // 🆕 精确的内容检测
  detectThinkingContent(text, raw, metadata = {}) {
    // 1. 显式工具调用
    if (raw?.type === 'tool_use') {
      return { subtype: 'tool_use', isVisible: false }
    }

    // 2. finish_reason 判断
    if (metadata.finishReason === 'end_turn') {
      return { subtype: 'message', isVisible: true }
    }

    // 3. JSON 特征判断
    try {
      const parsed = JSON.parse(text)
      if (parsed.type === 'thinking' ||
          parsed.type === 'tool_use' ||
          (parsed.isNewTopic !== undefined && parsed.title !== undefined)) {
        return { subtype: 'thinking', isVisible: false }
      }
    } catch {
      // 非 JSON，继续后续判断
    }

    // 4. 默认：正常消息
    return { subtype: 'message', isVisible: true }
  }
}
```

---

## ✅ 修正后的检查清单

### 核心修正
- [x] ✅ 保持构造函数签名不变，复用传入的 `requestId`
- [x] ✅ `captureStreamChunk` 保持同步，使用缓冲队列
- [x] ✅ 统一思考块处理逻辑：start 标记 → delta 累积 → stop 缓冲 → finalize 写入
- [x] ✅ 在 `finalizeStream` 批量写入，避免流阻塞

### 兼容性
- [x] ✅ 现有调用方无需修改
- [x] ✅ 所有参数向后兼容
- [x] ✅ 流式响应性能无影响

### 数据一致性
- [x] ✅ 同一轮次的所有消息共享同一个 `messageGroupId`
- [x] ✅ 思考块不会重复写入
- [x] ✅ 消息顺序保持时间线正确

---

## 🎯 最终方案总结

| 问题 | 原方案 | 修正方案 |
|------|--------|---------|
| 构造函数 | ❌ 重写签名，破坏调用 | ✅ 保持签名，新增字段 |
| requestId | ❌ 重新生成 | ✅ 复用传入的 |
| 流式写入 | ❌ 直接 await 阻塞 | ✅ 缓冲到队列 |
| 思考块 | ❌ start 和 stop 都写，重复 | ✅ 只在 stop 缓冲，finalize 写入 |

**修正后工作量：16-18 小时（不变）**

---

**这个修正版解决了所有高优先级问题，可以安全实施！**
